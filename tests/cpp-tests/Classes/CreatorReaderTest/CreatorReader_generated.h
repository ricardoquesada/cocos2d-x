// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace creator {
namespace buffers {

struct SceneGraph;

struct NodeTree;

struct SpriteFrame;

struct CreatorScene;

struct Node;

struct Sprite;

struct Label;

struct Particle;

struct TileMap;

struct Scene;

struct Button;

struct ProgressBar;

struct ScrollView;

struct Vec2;

struct Vec3;

struct Size;

struct Rect;

struct RGB;

struct RGBA;

enum FontType {
  FontType_System = 0,
  FontType_BMFont = 1,
  FontType_TTF = 2,
  FontType_MIN = FontType_System,
  FontType_MAX = FontType_TTF
};

inline const char **EnumNamesFontType() {
  static const char *names[] = { "System", "BMFont", "TTF", nullptr };
  return names;
}

inline const char *EnumNameFontType(FontType e) { return EnumNamesFontType()[static_cast<int>(e)]; }

enum VerticalAlignment {
  VerticalAlignment_Top = 0,
  VerticalAlignment_Center = 1,
  VerticalAlignment_Bottom = 2,
  VerticalAlignment_MIN = VerticalAlignment_Top,
  VerticalAlignment_MAX = VerticalAlignment_Bottom
};

inline const char **EnumNamesVerticalAlignment() {
  static const char *names[] = { "Top", "Center", "Bottom", nullptr };
  return names;
}

inline const char *EnumNameVerticalAlignment(VerticalAlignment e) { return EnumNamesVerticalAlignment()[static_cast<int>(e)]; }

enum HorizontalAlignment {
  HorizontalAlignment_Left = 0,
  HorizontalAlignment_Center = 1,
  HorizontalAlignment_Right = 2,
  HorizontalAlignment_MIN = HorizontalAlignment_Left,
  HorizontalAlignment_MAX = HorizontalAlignment_Right
};

inline const char **EnumNamesHorizontalAlignment() {
  static const char *names[] = { "Left", "Center", "Right", nullptr };
  return names;
}

inline const char *EnumNameHorizontalAlignment(HorizontalAlignment e) { return EnumNamesHorizontalAlignment()[static_cast<int>(e)]; }

enum SpriteType {
  SpriteType_Simple = 0,
  SpriteType_Sliced = 1,
  SpriteType_Tiled = 2,
  SpriteType_Filled = 3,
  SpriteType_MIN = SpriteType_Simple,
  SpriteType_MAX = SpriteType_Filled
};

inline const char **EnumNamesSpriteType() {
  static const char *names[] = { "Simple", "Sliced", "Tiled", "Filled", nullptr };
  return names;
}

inline const char *EnumNameSpriteType(SpriteType e) { return EnumNamesSpriteType()[static_cast<int>(e)]; }

enum AnyNode {
  AnyNode_NONE = 0,
  AnyNode_Scene = 1,
  AnyNode_Sprite = 2,
  AnyNode_Label = 3,
  AnyNode_Particle = 4,
  AnyNode_TileMap = 5,
  AnyNode_Node = 6,
  AnyNode_Button = 7,
  AnyNode_ProgressBar = 8,
  AnyNode_ScrollView = 9,
  AnyNode_CreatorScene = 10,
  AnyNode_MIN = AnyNode_NONE,
  AnyNode_MAX = AnyNode_CreatorScene
};

inline const char **EnumNamesAnyNode() {
  static const char *names[] = { "NONE", "Scene", "Sprite", "Label", "Particle", "TileMap", "Node", "Button", "ProgressBar", "ScrollView", "CreatorScene", nullptr };
  return names;
}

inline const char *EnumNameAnyNode(AnyNode e) { return EnumNamesAnyNode()[static_cast<int>(e)]; }

template<typename T> struct AnyNodeTraits {
  static const AnyNode enum_value = AnyNode_NONE;
};

template<> struct AnyNodeTraits<Scene> {
  static const AnyNode enum_value = AnyNode_Scene;
};

template<> struct AnyNodeTraits<Sprite> {
  static const AnyNode enum_value = AnyNode_Sprite;
};

template<> struct AnyNodeTraits<Label> {
  static const AnyNode enum_value = AnyNode_Label;
};

template<> struct AnyNodeTraits<Particle> {
  static const AnyNode enum_value = AnyNode_Particle;
};

template<> struct AnyNodeTraits<TileMap> {
  static const AnyNode enum_value = AnyNode_TileMap;
};

template<> struct AnyNodeTraits<Node> {
  static const AnyNode enum_value = AnyNode_Node;
};

template<> struct AnyNodeTraits<Button> {
  static const AnyNode enum_value = AnyNode_Button;
};

template<> struct AnyNodeTraits<ProgressBar> {
  static const AnyNode enum_value = AnyNode_ProgressBar;
};

template<> struct AnyNodeTraits<ScrollView> {
  static const AnyNode enum_value = AnyNode_ScrollView;
};

template<> struct AnyNodeTraits<CreatorScene> {
  static const AnyNode enum_value = AnyNode_CreatorScene;
};

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() { memset(this, 0, sizeof(Vec3)); }
  Vec3(const Vec3 &_o) { memcpy(this, &_o, sizeof(Vec3)); }
  Vec3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float h_;

 public:
  Size() { memset(this, 0, sizeof(Size)); }
  Size(const Size &_o) { memcpy(this, &_o, sizeof(Size)); }
  Size(float _w, float _h)
    : w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Size, 8);

MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  Rect() { memset(this, 0, sizeof(Rect)); }
  Rect(const Rect &_o) { memcpy(this, &_o, sizeof(Rect)); }
  Rect(float _x, float _y, float _w, float _h)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Rect, 16);

MANUALLY_ALIGNED_STRUCT(1) RGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  RGB() { memset(this, 0, sizeof(RGB)); }
  RGB(const RGB &_o) { memcpy(this, &_o, sizeof(RGB)); }
  RGB(uint8_t _r, uint8_t _g, uint8_t _b)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
};
STRUCT_END(RGB, 3);

MANUALLY_ALIGNED_STRUCT(1) RGBA FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  RGBA() { memset(this, 0, sizeof(RGBA)); }
  RGBA(const RGBA &_o) { memcpy(this, &_o, sizeof(RGBA)); }
  RGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
  uint8_t a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(RGBA, 4);

struct SceneGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_ROOT = 6,
    VT_DESIGNRESOLUTION = 8,
    VT_RESOLUTIONFITWIDTH = 10,
    VT_RESOLUTIONFITHEIGHT = 12,
    VT_SPRITEFRAMES = 14
  };
  const flatbuffers::String *version() const { return GetPointer<const flatbuffers::String *>(VT_VERSION); }
  const NodeTree *root() const { return GetPointer<const NodeTree *>(VT_ROOT); }
  const Size *designResolution() const { return GetStruct<const Size *>(VT_DESIGNRESOLUTION); }
  bool resolutionFitWidth() const { return GetField<uint8_t>(VT_RESOLUTIONFITWIDTH, 0) != 0; }
  bool resolutionFitHeight() const { return GetField<uint8_t>(VT_RESOLUTIONFITHEIGHT, 0) != 0; }
  const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *>(VT_SPRITEFRAMES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           VerifyField<Size>(verifier, VT_DESIGNRESOLUTION) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMES) &&
           verifier.Verify(spriteFrames()) &&
           verifier.VerifyVectorOfTables(spriteFrames()) &&
           verifier.EndTable();
  }
};

struct SceneGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) { fbb_.AddOffset(SceneGraph::VT_VERSION, version); }
  void add_root(flatbuffers::Offset<NodeTree> root) { fbb_.AddOffset(SceneGraph::VT_ROOT, root); }
  void add_designResolution(const Size *designResolution) { fbb_.AddStruct(SceneGraph::VT_DESIGNRESOLUTION, designResolution); }
  void add_resolutionFitWidth(bool resolutionFitWidth) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITWIDTH, static_cast<uint8_t>(resolutionFitWidth), 0); }
  void add_resolutionFitHeight(bool resolutionFitHeight) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITHEIGHT, static_cast<uint8_t>(resolutionFitHeight), 0); }
  void add_spriteFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames) { fbb_.AddOffset(SceneGraph::VT_SPRITEFRAMES, spriteFrames); }
  SceneGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneGraphBuilder &operator=(const SceneGraphBuilder &);
  flatbuffers::Offset<SceneGraph> Finish() {
    auto o = flatbuffers::Offset<SceneGraph>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<SceneGraph> CreateSceneGraph(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames = 0) {
  SceneGraphBuilder builder_(_fbb);
  builder_.add_spriteFrames(spriteFrames);
  builder_.add_designResolution(designResolution);
  builder_.add_root(root);
  builder_.add_version(version);
  builder_.add_resolutionFitHeight(resolutionFitHeight);
  builder_.add_resolutionFitWidth(resolutionFitWidth);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneGraph> CreateSceneGraphDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    const std::vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames = nullptr) {
  return CreateSceneGraph(_fbb, version ? _fbb.CreateString(version) : 0, root, designResolution, resolutionFitWidth, resolutionFitHeight, spriteFrames ? _fbb.CreateVector<flatbuffers::Offset<SpriteFrame>>(*spriteFrames) : 0);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHILDREN = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN); }
  AnyNode object_type() const { return static_cast<AnyNode>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyAnyNode(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) { fbb_.AddOffset(NodeTree::VT_CHILDREN, children); }
  void add_object_type(AnyNode object_type) { fbb_.AddElement<uint8_t>(NodeTree::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(NodeTree::VT_OBJECT, object); }
  NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    auto o = flatbuffers::Offset<NodeTree>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_children(children);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateNodeTree(_fbb, children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0, object_type, object);
}

struct SpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TEXTUREPATH = 6,
    VT_RECT = 8,
    VT_OFFSET = 10,
    VT_ROTATED = 12,
    VT_ORIGINALSIZE = 14,
    VT_CENTERRECT = 16
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const flatbuffers::String *texturePath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREPATH); }
  const Rect *rect() const { return GetStruct<const Rect *>(VT_RECT); }
  const Vec2 *offset() const { return GetStruct<const Vec2 *>(VT_OFFSET); }
  bool rotated() const { return GetField<uint8_t>(VT_ROTATED, 0) != 0; }
  const Size *originalSize() const { return GetStruct<const Size *>(VT_ORIGINALSIZE); }
  const Rect *centerRect() const { return GetStruct<const Rect *>(VT_CENTERRECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREPATH) &&
           verifier.Verify(texturePath()) &&
           VerifyField<Rect>(verifier, VT_RECT) &&
           VerifyField<Vec2>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_ROTATED) &&
           VerifyField<Size>(verifier, VT_ORIGINALSIZE) &&
           VerifyField<Rect>(verifier, VT_CENTERRECT) &&
           verifier.EndTable();
  }
};

struct SpriteFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SpriteFrame::VT_NAME, name); }
  void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath) { fbb_.AddOffset(SpriteFrame::VT_TEXTUREPATH, texturePath); }
  void add_rect(const Rect *rect) { fbb_.AddStruct(SpriteFrame::VT_RECT, rect); }
  void add_offset(const Vec2 *offset) { fbb_.AddStruct(SpriteFrame::VT_OFFSET, offset); }
  void add_rotated(bool rotated) { fbb_.AddElement<uint8_t>(SpriteFrame::VT_ROTATED, static_cast<uint8_t>(rotated), 0); }
  void add_originalSize(const Size *originalSize) { fbb_.AddStruct(SpriteFrame::VT_ORIGINALSIZE, originalSize); }
  void add_centerRect(const Rect *centerRect) { fbb_.AddStruct(SpriteFrame::VT_CENTERRECT, centerRect); }
  SpriteFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteFrameBuilder &operator=(const SpriteFrameBuilder &);
  flatbuffers::Offset<SpriteFrame> Finish() {
    auto o = flatbuffers::Offset<SpriteFrame>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrame(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> texturePath = 0,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  SpriteFrameBuilder builder_(_fbb);
  builder_.add_centerRect(centerRect);
  builder_.add_originalSize(originalSize);
  builder_.add_offset(offset);
  builder_.add_rect(rect);
  builder_.add_texturePath(texturePath);
  builder_.add_name(name);
  builder_.add_rotated(rotated);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrameDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *texturePath = nullptr,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  return CreateSpriteFrame(_fbb, name ? _fbb.CreateString(name) : 0, texturePath ? _fbb.CreateString(texturePath) : 0, rect, offset, rotated, originalSize, centerRect);
}

struct CreatorScene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4
  };
  const flatbuffers::String *filename() const { return GetPointer<const flatbuffers::String *>(VT_FILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           verifier.EndTable();
  }
};

struct CreatorSceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) { fbb_.AddOffset(CreatorScene::VT_FILENAME, filename); }
  CreatorSceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CreatorSceneBuilder &operator=(const CreatorSceneBuilder &);
  flatbuffers::Offset<CreatorScene> Finish() {
    auto o = flatbuffers::Offset<CreatorScene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<CreatorScene> CreateCreatorScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0) {
  CreatorSceneBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreatorScene> CreateCreatorSceneDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  return CreateCreatorScene(_fbb, filename ? _fbb.CreateString(filename) : 0);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTSIZE = 4,
    VT_ENABLED = 6,
    VT_NAME = 8,
    VT_ANCHORPOINT = 10,
    VT_CASCADEOPACITYENABLED = 12,
    VT_COLOR = 14,
    VT_GLOBALZORDER = 16,
    VT_LOCALZORDER = 18,
    VT_OPACITY = 20,
    VT_OPACITYMODIFYRGB = 22,
    VT_POSITION = 24,
    VT_ROTATIONSKEWX = 26,
    VT_ROTATIONSKEWY = 28,
    VT_SCALEX = 30,
    VT_SCALEY = 32,
    VT_SKEWX = 34,
    VT_SKEWY = 36,
    VT_TAG = 38
  };
  const Size *contentSize() const { return GetStruct<const Size *>(VT_CONTENTSIZE); }
  bool enabled() const { return GetField<uint8_t>(VT_ENABLED, 1) != 0; }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Vec2 *anchorPoint() const { return GetStruct<const Vec2 *>(VT_ANCHORPOINT); }
  bool cascadeOpacityEnabled() const { return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 1) != 0; }
  const RGB *color() const { return GetStruct<const RGB *>(VT_COLOR); }
  float globalZOrder() const { return GetField<float>(VT_GLOBALZORDER, 0.0f); }
  int32_t localZOrder() const { return GetField<int32_t>(VT_LOCALZORDER, 0); }
  uint8_t opacity() const { return GetField<uint8_t>(VT_OPACITY, 255); }
  bool opacityModifyRGB() const { return GetField<uint8_t>(VT_OPACITYMODIFYRGB, 1) != 0; }
  const Vec2 *position() const { return GetStruct<const Vec2 *>(VT_POSITION); }
  float rotationSkewX() const { return GetField<float>(VT_ROTATIONSKEWX, 0.0f); }
  float rotationSkewY() const { return GetField<float>(VT_ROTATIONSKEWY, 0.0f); }
  float scaleX() const { return GetField<float>(VT_SCALEX, 1.0f); }
  float scaleY() const { return GetField<float>(VT_SCALEY, 1.0f); }
  float skewX() const { return GetField<float>(VT_SKEWX, 0.0f); }
  float skewY() const { return GetField<float>(VT_SKEWY, 0.0f); }
  int32_t tag() const { return GetField<int32_t>(VT_TAG, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Size>(verifier, VT_CONTENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<Vec2>(verifier, VT_ANCHORPOINT) &&
           VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED) &&
           VerifyField<RGB>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_GLOBALZORDER) &&
           VerifyField<int32_t>(verifier, VT_LOCALZORDER) &&
           VerifyField<uint8_t>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_OPACITYMODIFYRGB) &&
           VerifyField<Vec2>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWX) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWY) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_SKEWX) &&
           VerifyField<float>(verifier, VT_SKEWY) &&
           VerifyField<int32_t>(verifier, VT_TAG) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentSize(const Size *contentSize) { fbb_.AddStruct(Node::VT_CONTENTSIZE, contentSize); }
  void add_enabled(bool enabled) { fbb_.AddElement<uint8_t>(Node::VT_ENABLED, static_cast<uint8_t>(enabled), 1); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Node::VT_NAME, name); }
  void add_anchorPoint(const Vec2 *anchorPoint) { fbb_.AddStruct(Node::VT_ANCHORPOINT, anchorPoint); }
  void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled) { fbb_.AddElement<uint8_t>(Node::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 1); }
  void add_color(const RGB *color) { fbb_.AddStruct(Node::VT_COLOR, color); }
  void add_globalZOrder(float globalZOrder) { fbb_.AddElement<float>(Node::VT_GLOBALZORDER, globalZOrder, 0.0f); }
  void add_localZOrder(int32_t localZOrder) { fbb_.AddElement<int32_t>(Node::VT_LOCALZORDER, localZOrder, 0); }
  void add_opacity(uint8_t opacity) { fbb_.AddElement<uint8_t>(Node::VT_OPACITY, opacity, 255); }
  void add_opacityModifyRGB(bool opacityModifyRGB) { fbb_.AddElement<uint8_t>(Node::VT_OPACITYMODIFYRGB, static_cast<uint8_t>(opacityModifyRGB), 1); }
  void add_position(const Vec2 *position) { fbb_.AddStruct(Node::VT_POSITION, position); }
  void add_rotationSkewX(float rotationSkewX) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWX, rotationSkewX, 0.0f); }
  void add_rotationSkewY(float rotationSkewY) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWY, rotationSkewY, 0.0f); }
  void add_scaleX(float scaleX) { fbb_.AddElement<float>(Node::VT_SCALEX, scaleX, 1.0f); }
  void add_scaleY(float scaleY) { fbb_.AddElement<float>(Node::VT_SCALEY, scaleY, 1.0f); }
  void add_skewX(float skewX) { fbb_.AddElement<float>(Node::VT_SKEWX, skewX, 0.0f); }
  void add_skewY(float skewY) { fbb_.AddElement<float>(Node::VT_SKEWY, skewY, 0.0f); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(Node::VT_TAG, tag, 0); }
  NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    auto o = flatbuffers::Offset<Node>(fbb_.EndTable(start_, 18));
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const RGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationSkewY(rotationSkewY);
  builder_.add_rotationSkewX(rotationSkewX);
  builder_.add_position(position);
  builder_.add_localZOrder(localZOrder);
  builder_.add_globalZOrder(globalZOrder);
  builder_.add_color(color);
  builder_.add_anchorPoint(anchorPoint);
  builder_.add_name(name);
  builder_.add_contentSize(contentSize);
  builder_.add_opacityModifyRGB(opacityModifyRGB);
  builder_.add_opacity(opacity);
  builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    const char *name = nullptr,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const RGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0) {
  return CreateNode(_fbb, contentSize, enabled, name ? _fbb.CreateString(name) : 0, anchorPoint, cascadeOpacityEnabled, color, globalZOrder, localZOrder, opacity, opacityModifyRGB, position, rotationSkewX, rotationSkewY, scaleX, scaleY, skewX, skewY, tag);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_SPRITEFRAMENAME = 6,
    VT_SPRITETYPE = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  SpriteType spriteType() const { return static_cast<SpriteType>(GetField<int8_t>(VT_SPRITETYPE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<int8_t>(verifier, VT_SPRITETYPE) &&
           verifier.EndTable();
  }
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Sprite::VT_NODE, node); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Sprite::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_spriteType(SpriteType spriteType) { fbb_.AddElement<int8_t>(Sprite::VT_SPRITETYPE, static_cast<int8_t>(spriteType), 0); }
  SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    auto o = flatbuffers::Offset<Sprite>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    SpriteType spriteType = SpriteType_Simple) {
  SpriteBuilder builder_(_fbb);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_node(node);
  builder_.add_spriteType(spriteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *spriteFrameName = nullptr,
    SpriteType spriteType = SpriteType_Simple) {
  return CreateSprite(_fbb, node, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, spriteType);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_LABELTEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_VERTICALALIGNMENT = 10,
    VT_LINEHEIGHT = 12,
    VT_FONTNAME = 14,
    VT_FONTSIZE = 16,
    VT_FONTTYPE = 18
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *labelText() const { return GetPointer<const flatbuffers::String *>(VT_LABELTEXT); }
  HorizontalAlignment horizontalAlignment() const { return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0)); }
  VerticalAlignment verticalAlignment() const { return static_cast<VerticalAlignment>(GetField<int8_t>(VT_VERTICALALIGNMENT, 0)); }
  float lineHeight() const { return GetField<float>(VT_LINEHEIGHT, 0.0f); }
  const flatbuffers::String *fontName() const { return GetPointer<const flatbuffers::String *>(VT_FONTNAME); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  FontType fontType() const { return static_cast<FontType>(GetField<int8_t>(VT_FONTTYPE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABELTEXT) &&
           verifier.Verify(labelText()) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<int8_t>(verifier, VT_VERTICALALIGNMENT) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FONTNAME) &&
           verifier.Verify(fontName()) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<int8_t>(verifier, VT_FONTTYPE) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Label::VT_NODE, node); }
  void add_labelText(flatbuffers::Offset<flatbuffers::String> labelText) { fbb_.AddOffset(Label::VT_LABELTEXT, labelText); }
  void add_horizontalAlignment(HorizontalAlignment horizontalAlignment) { fbb_.AddElement<int8_t>(Label::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0); }
  void add_verticalAlignment(VerticalAlignment verticalAlignment) { fbb_.AddElement<int8_t>(Label::VT_VERTICALALIGNMENT, static_cast<int8_t>(verticalAlignment), 0); }
  void add_lineHeight(float lineHeight) { fbb_.AddElement<float>(Label::VT_LINEHEIGHT, lineHeight, 0.0f); }
  void add_fontName(flatbuffers::Offset<flatbuffers::String> fontName) { fbb_.AddOffset(Label::VT_FONTNAME, fontName); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(Label::VT_FONTSIZE, fontSize, 0.0f); }
  void add_fontType(FontType fontType) { fbb_.AddElement<int8_t>(Label::VT_FONTTYPE, static_cast<int8_t>(fontType), 0); }
  LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    auto o = flatbuffers::Offset<Label>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> labelText = 0,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    flatbuffers::Offset<flatbuffers::String> fontName = 0,
    float fontSize = 0.0f,
    FontType fontType = FontType_System) {
  LabelBuilder builder_(_fbb);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_lineHeight(lineHeight);
  builder_.add_labelText(labelText);
  builder_.add_node(node);
  builder_.add_fontType(fontType);
  builder_.add_verticalAlignment(verticalAlignment);
  builder_.add_horizontalAlignment(horizontalAlignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *labelText = nullptr,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    const char *fontName = nullptr,
    float fontSize = 0.0f,
    FontType fontType = FontType_System) {
  return CreateLabel(_fbb, node, labelText ? _fbb.CreateString(labelText) : 0, horizontalAlignment, verticalAlignment, lineHeight, fontName ? _fbb.CreateString(fontName) : 0, fontSize, fontType);
}

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PLISTFILE = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *plistFile() const { return GetPointer<const flatbuffers::String *>(VT_PLISTFILE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLISTFILE) &&
           verifier.Verify(plistFile()) &&
           verifier.EndTable();
  }
};

struct ParticleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Particle::VT_NODE, node); }
  void add_plistFile(flatbuffers::Offset<flatbuffers::String> plistFile) { fbb_.AddOffset(Particle::VT_PLISTFILE, plistFile); }
  ParticleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ParticleBuilder &operator=(const ParticleBuilder &);
  flatbuffers::Offset<Particle> Finish() {
    auto o = flatbuffers::Offset<Particle>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Particle> CreateParticle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> plistFile = 0) {
  ParticleBuilder builder_(_fbb);
  builder_.add_plistFile(plistFile);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *plistFile = nullptr) {
  return CreateParticle(_fbb, node, plistFile ? _fbb.CreateString(plistFile) : 0);
}

struct TileMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TMXFILE = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *tmxFile() const { return GetPointer<const flatbuffers::String *>(VT_TMXFILE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TMXFILE) &&
           verifier.Verify(tmxFile()) &&
           verifier.EndTable();
  }
};

struct TileMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(TileMap::VT_NODE, node); }
  void add_tmxFile(flatbuffers::Offset<flatbuffers::String> tmxFile) { fbb_.AddOffset(TileMap::VT_TMXFILE, tmxFile); }
  TileMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileMapBuilder &operator=(const TileMapBuilder &);
  flatbuffers::Offset<TileMap> Finish() {
    auto o = flatbuffers::Offset<TileMap>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<TileMap> CreateTileMap(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> tmxFile = 0) {
  TileMapBuilder builder_(_fbb);
  builder_.add_tmxFile(tmxFile);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileMap> CreateTileMapDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *tmxFile = nullptr) {
  return CreateTileMap(_fbb, node, tmxFile ? _fbb.CreateString(tmxFile) : 0);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Scene::VT_NODE, node); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_IGNORECONTENTADAPTWITHSIZE = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool ignoreContentAdaptWithSize() const { return GetField<uint8_t>(VT_IGNORECONTENTADAPTWITHSIZE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<uint8_t>(verifier, VT_IGNORECONTENTADAPTWITHSIZE) &&
           verifier.EndTable();
  }
};

struct ButtonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Button::VT_NODE, node); }
  void add_ignoreContentAdaptWithSize(bool ignoreContentAdaptWithSize) { fbb_.AddElement<uint8_t>(Button::VT_IGNORECONTENTADAPTWITHSIZE, static_cast<uint8_t>(ignoreContentAdaptWithSize), 0); }
  ButtonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ButtonBuilder &operator=(const ButtonBuilder &);
  flatbuffers::Offset<Button> Finish() {
    auto o = flatbuffers::Offset<Button>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool ignoreContentAdaptWithSize = false) {
  ButtonBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_ignoreContentAdaptWithSize(ignoreContentAdaptWithSize);
  return builder_.Finish();
}

struct ProgressBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct ProgressBarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ProgressBar::VT_NODE, node); }
  ProgressBarBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProgressBarBuilder &operator=(const ProgressBarBuilder &);
  flatbuffers::Offset<ProgressBar> Finish() {
    auto o = flatbuffers::Offset<ProgressBar>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ProgressBar> CreateProgressBar(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  ProgressBarBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct ScrollView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct ScrollViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ScrollView::VT_NODE, node); }
  ScrollViewBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ScrollViewBuilder &operator=(const ScrollViewBuilder &);
  flatbuffers::Offset<ScrollView> Finish() {
    auto o = flatbuffers::Offset<ScrollView>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ScrollView> CreateScrollView(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  ScrollViewBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type) {
  switch (type) {
    case AnyNode_NONE: return true;
    case AnyNode_Scene: return verifier.VerifyTable(reinterpret_cast<const Scene *>(union_obj));
    case AnyNode_Sprite: return verifier.VerifyTable(reinterpret_cast<const Sprite *>(union_obj));
    case AnyNode_Label: return verifier.VerifyTable(reinterpret_cast<const Label *>(union_obj));
    case AnyNode_Particle: return verifier.VerifyTable(reinterpret_cast<const Particle *>(union_obj));
    case AnyNode_TileMap: return verifier.VerifyTable(reinterpret_cast<const TileMap *>(union_obj));
    case AnyNode_Node: return verifier.VerifyTable(reinterpret_cast<const Node *>(union_obj));
    case AnyNode_Button: return verifier.VerifyTable(reinterpret_cast<const Button *>(union_obj));
    case AnyNode_ProgressBar: return verifier.VerifyTable(reinterpret_cast<const ProgressBar *>(union_obj));
    case AnyNode_ScrollView: return verifier.VerifyTable(reinterpret_cast<const ScrollView *>(union_obj));
    case AnyNode_CreatorScene: return verifier.VerifyTable(reinterpret_cast<const CreatorScene *>(union_obj));
    default: return false;
  }
}

inline const creator::buffers::SceneGraph *GetSceneGraph(const void *buf) {
  return flatbuffers::GetRoot<creator::buffers::SceneGraph>(buf);
}

inline const char *SceneGraphIdentifier() {
  return "CCRE";
}

inline bool SceneGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, SceneGraphIdentifier());
}

inline bool VerifySceneGraphBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<creator::buffers::SceneGraph>(SceneGraphIdentifier());
}

inline const char *SceneGraphExtension() { return "ccreator"; }

inline void FinishSceneGraphBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<creator::buffers::SceneGraph> root) {
  fbb.Finish(root, SceneGraphIdentifier());
}

}  // namespace buffers
}  // namespace creator

#endif  // FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
