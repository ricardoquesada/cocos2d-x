// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace creator {
namespace buffers {

struct SceneGraph;

struct NodeTree;

struct Node;

struct Sprite;

struct Label;

struct Particle;

struct TileMap;

struct Scene;

struct Vec2;

struct Vec3;

struct Size;

struct Rect;

struct RGB;

struct RGBA;

enum FontType {
  FontType_System = 0,
  FontType_BMFont = 1,
  FontType_TTF = 2,
  FontType_MIN = FontType_System,
  FontType_MAX = FontType_TTF
};

inline const char **EnumNamesFontType() {
  static const char *names[] = { "System", "BMFont", "TTF", nullptr };
  return names;
}

inline const char *EnumNameFontType(FontType e) { return EnumNamesFontType()[static_cast<int>(e)]; }

enum AnyNode {
  AnyNode_NONE = 0,
  AnyNode_Scene = 1,
  AnyNode_Sprite = 2,
  AnyNode_Label = 3,
  AnyNode_Particle = 4,
  AnyNode_TileMap = 5,
  AnyNode_Node = 6,
  AnyNode_MIN = AnyNode_NONE,
  AnyNode_MAX = AnyNode_Node
};

inline const char **EnumNamesAnyNode() {
  static const char *names[] = { "NONE", "Scene", "Sprite", "Label", "Particle", "TileMap", "Node", nullptr };
  return names;
}

inline const char *EnumNameAnyNode(AnyNode e) { return EnumNamesAnyNode()[static_cast<int>(e)]; }

template<typename T> struct AnyNodeTraits {
  static const AnyNode enum_value = AnyNode_NONE;
};

template<> struct AnyNodeTraits<Scene> {
  static const AnyNode enum_value = AnyNode_Scene;
};

template<> struct AnyNodeTraits<Sprite> {
  static const AnyNode enum_value = AnyNode_Sprite;
};

template<> struct AnyNodeTraits<Label> {
  static const AnyNode enum_value = AnyNode_Label;
};

template<> struct AnyNodeTraits<Particle> {
  static const AnyNode enum_value = AnyNode_Particle;
};

template<> struct AnyNodeTraits<TileMap> {
  static const AnyNode enum_value = AnyNode_TileMap;
};

template<> struct AnyNodeTraits<Node> {
  static const AnyNode enum_value = AnyNode_Node;
};

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() { memset(this, 0, sizeof(Vec3)); }
  Vec3(const Vec3 &_o) { memcpy(this, &_o, sizeof(Vec3)); }
  Vec3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float h_;

 public:
  Size() { memset(this, 0, sizeof(Size)); }
  Size(const Size &_o) { memcpy(this, &_o, sizeof(Size)); }
  Size(float _w, float _h)
    : w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Size, 8);

MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  Rect() { memset(this, 0, sizeof(Rect)); }
  Rect(const Rect &_o) { memcpy(this, &_o, sizeof(Rect)); }
  Rect(float _x, float _y, float _w, float _h)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Rect, 16);

MANUALLY_ALIGNED_STRUCT(1) RGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  RGB() { memset(this, 0, sizeof(RGB)); }
  RGB(const RGB &_o) { memcpy(this, &_o, sizeof(RGB)); }
  RGB(uint8_t _r, uint8_t _g, uint8_t _b)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
};
STRUCT_END(RGB, 3);

MANUALLY_ALIGNED_STRUCT(1) RGBA FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  RGBA() { memset(this, 0, sizeof(RGBA)); }
  RGBA(const RGBA &_o) { memcpy(this, &_o, sizeof(RGBA)); }
  RGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
  uint8_t a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(RGBA, 4);

struct SceneGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_ROOT = 6
  };
  const flatbuffers::String *version() const { return GetPointer<const flatbuffers::String *>(VT_VERSION); }
  const NodeTree *root() const { return GetPointer<const NodeTree *>(VT_ROOT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           verifier.EndTable();
  }
};

struct SceneGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) { fbb_.AddOffset(SceneGraph::VT_VERSION, version); }
  void add_root(flatbuffers::Offset<NodeTree> root) { fbb_.AddOffset(SceneGraph::VT_ROOT, root); }
  SceneGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneGraphBuilder &operator=(const SceneGraphBuilder &);
  flatbuffers::Offset<SceneGraph> Finish() {
    auto o = flatbuffers::Offset<SceneGraph>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SceneGraph> CreateSceneGraph(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<NodeTree> root = 0) {
  SceneGraphBuilder builder_(_fbb);
  builder_.add_root(root);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneGraph> CreateSceneGraphDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<NodeTree> root = 0) {
  return CreateSceneGraph(_fbb, version ? _fbb.CreateString(version) : 0, root);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLASSNAME = 4,
    VT_CUSTOMCLASSNAME = 6,
    VT_CHILDREN = 8,
    VT_OBJECT_TYPE = 10,
    VT_OBJECT = 12
  };
  const flatbuffers::String *classname() const { return GetPointer<const flatbuffers::String *>(VT_CLASSNAME); }
  const flatbuffers::String *customClassName() const { return GetPointer<const flatbuffers::String *>(VT_CUSTOMCLASSNAME); }
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN); }
  AnyNode object_type() const { return static_cast<AnyNode>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLASSNAME) &&
           verifier.Verify(classname()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CUSTOMCLASSNAME) &&
           verifier.Verify(customClassName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyAnyNode(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classname(flatbuffers::Offset<flatbuffers::String> classname) { fbb_.AddOffset(NodeTree::VT_CLASSNAME, classname); }
  void add_customClassName(flatbuffers::Offset<flatbuffers::String> customClassName) { fbb_.AddOffset(NodeTree::VT_CUSTOMCLASSNAME, customClassName); }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) { fbb_.AddOffset(NodeTree::VT_CHILDREN, children); }
  void add_object_type(AnyNode object_type) { fbb_.AddElement<uint8_t>(NodeTree::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(NodeTree::VT_OBJECT, object); }
  NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    auto o = flatbuffers::Offset<NodeTree>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> classname = 0,
    flatbuffers::Offset<flatbuffers::String> customClassName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_children(children);
  builder_.add_customClassName(customClassName);
  builder_.add_classname(classname);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *classname = nullptr,
    const char *customClassName = nullptr,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateNodeTree(_fbb, classname ? _fbb.CreateString(classname) : 0, customClassName ? _fbb.CreateString(customClassName) : 0, children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0, object_type, object);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTSIZE = 4,
    VT_ENABLED = 6,
    VT_NAME = 8,
    VT_ANCHORPOINT = 10,
    VT_CASCADEOPACITYENABLED = 12,
    VT_COLOR = 14,
    VT_GLOBALZORDER = 16,
    VT_LOCALZORDER = 18,
    VT_OPACITY = 20,
    VT_OPACITYMODIFYRGB = 22,
    VT_POSITION = 24,
    VT_ROTATIONSKEW = 26,
    VT_SCALE = 28,
    VT_TAG = 30
  };
  const Size *contentSize() const { return GetStruct<const Size *>(VT_CONTENTSIZE); }
  bool enabled() const { return GetField<uint8_t>(VT_ENABLED, 1) != 0; }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Vec2 *anchorPoint() const { return GetStruct<const Vec2 *>(VT_ANCHORPOINT); }
  bool cascadeOpacityEnabled() const { return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 1) != 0; }
  const RGB *color() const { return GetStruct<const RGB *>(VT_COLOR); }
  int32_t globalZorder() const { return GetField<int32_t>(VT_GLOBALZORDER, 0); }
  int32_t localZorder() const { return GetField<int32_t>(VT_LOCALZORDER, 0); }
  uint8_t opacity() const { return GetField<uint8_t>(VT_OPACITY, 255); }
  bool opacityModifyRGB() const { return GetField<uint8_t>(VT_OPACITYMODIFYRGB, 1) != 0; }
  const Vec2 *position() const { return GetStruct<const Vec2 *>(VT_POSITION); }
  const Vec2 *rotationSkew() const { return GetStruct<const Vec2 *>(VT_ROTATIONSKEW); }
  const Vec2 *scale() const { return GetStruct<const Vec2 *>(VT_SCALE); }
  int32_t tag() const { return GetField<int32_t>(VT_TAG, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Size>(verifier, VT_CONTENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<Vec2>(verifier, VT_ANCHORPOINT) &&
           VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED) &&
           VerifyField<RGB>(verifier, VT_COLOR) &&
           VerifyField<int32_t>(verifier, VT_GLOBALZORDER) &&
           VerifyField<int32_t>(verifier, VT_LOCALZORDER) &&
           VerifyField<uint8_t>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_OPACITYMODIFYRGB) &&
           VerifyField<Vec2>(verifier, VT_POSITION) &&
           VerifyField<Vec2>(verifier, VT_ROTATIONSKEW) &&
           VerifyField<Vec2>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_TAG) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentSize(const Size *contentSize) { fbb_.AddStruct(Node::VT_CONTENTSIZE, contentSize); }
  void add_enabled(bool enabled) { fbb_.AddElement<uint8_t>(Node::VT_ENABLED, static_cast<uint8_t>(enabled), 1); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Node::VT_NAME, name); }
  void add_anchorPoint(const Vec2 *anchorPoint) { fbb_.AddStruct(Node::VT_ANCHORPOINT, anchorPoint); }
  void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled) { fbb_.AddElement<uint8_t>(Node::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 1); }
  void add_color(const RGB *color) { fbb_.AddStruct(Node::VT_COLOR, color); }
  void add_globalZorder(int32_t globalZorder) { fbb_.AddElement<int32_t>(Node::VT_GLOBALZORDER, globalZorder, 0); }
  void add_localZorder(int32_t localZorder) { fbb_.AddElement<int32_t>(Node::VT_LOCALZORDER, localZorder, 0); }
  void add_opacity(uint8_t opacity) { fbb_.AddElement<uint8_t>(Node::VT_OPACITY, opacity, 255); }
  void add_opacityModifyRGB(bool opacityModifyRGB) { fbb_.AddElement<uint8_t>(Node::VT_OPACITYMODIFYRGB, static_cast<uint8_t>(opacityModifyRGB), 1); }
  void add_position(const Vec2 *position) { fbb_.AddStruct(Node::VT_POSITION, position); }
  void add_rotationSkew(const Vec2 *rotationSkew) { fbb_.AddStruct(Node::VT_ROTATIONSKEW, rotationSkew); }
  void add_scale(const Vec2 *scale) { fbb_.AddStruct(Node::VT_SCALE, scale); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(Node::VT_TAG, tag, 0); }
  NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    auto o = flatbuffers::Offset<Node>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const RGB *color = 0,
    int32_t globalZorder = 0,
    int32_t localZorder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    const Vec2 *rotationSkew = 0,
    const Vec2 *scale = 0,
    int32_t tag = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_scale(scale);
  builder_.add_rotationSkew(rotationSkew);
  builder_.add_position(position);
  builder_.add_localZorder(localZorder);
  builder_.add_globalZorder(globalZorder);
  builder_.add_color(color);
  builder_.add_anchorPoint(anchorPoint);
  builder_.add_name(name);
  builder_.add_contentSize(contentSize);
  builder_.add_opacityModifyRGB(opacityModifyRGB);
  builder_.add_opacity(opacity);
  builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    const char *name = nullptr,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const RGB *color = 0,
    int32_t globalZorder = 0,
    int32_t localZorder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    const Vec2 *rotationSkew = 0,
    const Vec2 *scale = 0,
    int32_t tag = 0) {
  return CreateNode(_fbb, contentSize, enabled, name ? _fbb.CreateString(name) : 0, anchorPoint, cascadeOpacityEnabled, color, globalZorder, localZorder, opacity, opacityModifyRGB, position, rotationSkew, scale, tag);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_SPRITEFRAMENAME = 6,
    VT_CENTERRECT = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  const Rect *centerRect() const { return GetStruct<const Rect *>(VT_CENTERRECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<Rect>(verifier, VT_CENTERRECT) &&
           verifier.EndTable();
  }
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Sprite::VT_NODE, node); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Sprite::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_centerRect(const Rect *centerRect) { fbb_.AddStruct(Sprite::VT_CENTERRECT, centerRect); }
  SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    auto o = flatbuffers::Offset<Sprite>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    const Rect *centerRect = 0) {
  SpriteBuilder builder_(_fbb);
  builder_.add_centerRect(centerRect);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *spriteFrameName = nullptr,
    const Rect *centerRect = 0) {
  return CreateSprite(_fbb, node, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, centerRect);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_LABELTEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_VERTICALALIGNMENT = 10,
    VT_FONTSIZE = 12,
    VT_FONTTYPE = 14
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *labelText() const { return GetPointer<const flatbuffers::String *>(VT_LABELTEXT); }
  float horizontalAlignment() const { return GetField<float>(VT_HORIZONTALALIGNMENT, 0.0f); }
  float verticalAlignment() const { return GetField<float>(VT_VERTICALALIGNMENT, 0.0f); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  FontType fontType() const { return static_cast<FontType>(GetField<int8_t>(VT_FONTTYPE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABELTEXT) &&
           verifier.Verify(labelText()) &&
           VerifyField<float>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<float>(verifier, VT_VERTICALALIGNMENT) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<int8_t>(verifier, VT_FONTTYPE) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Label::VT_NODE, node); }
  void add_labelText(flatbuffers::Offset<flatbuffers::String> labelText) { fbb_.AddOffset(Label::VT_LABELTEXT, labelText); }
  void add_horizontalAlignment(float horizontalAlignment) { fbb_.AddElement<float>(Label::VT_HORIZONTALALIGNMENT, horizontalAlignment, 0.0f); }
  void add_verticalAlignment(float verticalAlignment) { fbb_.AddElement<float>(Label::VT_VERTICALALIGNMENT, verticalAlignment, 0.0f); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(Label::VT_FONTSIZE, fontSize, 0.0f); }
  void add_fontType(FontType fontType) { fbb_.AddElement<int8_t>(Label::VT_FONTTYPE, static_cast<int8_t>(fontType), 0); }
  LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    auto o = flatbuffers::Offset<Label>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> labelText = 0,
    float horizontalAlignment = 0.0f,
    float verticalAlignment = 0.0f,
    float fontSize = 0.0f,
    FontType fontType = FontType_System) {
  LabelBuilder builder_(_fbb);
  builder_.add_fontSize(fontSize);
  builder_.add_verticalAlignment(verticalAlignment);
  builder_.add_horizontalAlignment(horizontalAlignment);
  builder_.add_labelText(labelText);
  builder_.add_node(node);
  builder_.add_fontType(fontType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *labelText = nullptr,
    float horizontalAlignment = 0.0f,
    float verticalAlignment = 0.0f,
    float fontSize = 0.0f,
    FontType fontType = FontType_System) {
  return CreateLabel(_fbb, node, labelText ? _fbb.CreateString(labelText) : 0, horizontalAlignment, verticalAlignment, fontSize, fontType);
}

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PLISTFILE = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *plistFile() const { return GetPointer<const flatbuffers::String *>(VT_PLISTFILE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLISTFILE) &&
           verifier.Verify(plistFile()) &&
           verifier.EndTable();
  }
};

struct ParticleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Particle::VT_NODE, node); }
  void add_plistFile(flatbuffers::Offset<flatbuffers::String> plistFile) { fbb_.AddOffset(Particle::VT_PLISTFILE, plistFile); }
  ParticleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ParticleBuilder &operator=(const ParticleBuilder &);
  flatbuffers::Offset<Particle> Finish() {
    auto o = flatbuffers::Offset<Particle>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Particle> CreateParticle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> plistFile = 0) {
  ParticleBuilder builder_(_fbb);
  builder_.add_plistFile(plistFile);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *plistFile = nullptr) {
  return CreateParticle(_fbb, node, plistFile ? _fbb.CreateString(plistFile) : 0);
}

struct TileMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TMXFILE = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *tmxFile() const { return GetPointer<const flatbuffers::String *>(VT_TMXFILE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TMXFILE) &&
           verifier.Verify(tmxFile()) &&
           verifier.EndTable();
  }
};

struct TileMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(TileMap::VT_NODE, node); }
  void add_tmxFile(flatbuffers::Offset<flatbuffers::String> tmxFile) { fbb_.AddOffset(TileMap::VT_TMXFILE, tmxFile); }
  TileMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileMapBuilder &operator=(const TileMapBuilder &);
  flatbuffers::Offset<TileMap> Finish() {
    auto o = flatbuffers::Offset<TileMap>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<TileMap> CreateTileMap(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> tmxFile = 0) {
  TileMapBuilder builder_(_fbb);
  builder_.add_tmxFile(tmxFile);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileMap> CreateTileMapDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *tmxFile = nullptr) {
  return CreateTileMap(_fbb, node, tmxFile ? _fbb.CreateString(tmxFile) : 0);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Scene::VT_NODE, node); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type) {
  switch (type) {
    case AnyNode_NONE: return true;
    case AnyNode_Scene: return verifier.VerifyTable(reinterpret_cast<const Scene *>(union_obj));
    case AnyNode_Sprite: return verifier.VerifyTable(reinterpret_cast<const Sprite *>(union_obj));
    case AnyNode_Label: return verifier.VerifyTable(reinterpret_cast<const Label *>(union_obj));
    case AnyNode_Particle: return verifier.VerifyTable(reinterpret_cast<const Particle *>(union_obj));
    case AnyNode_TileMap: return verifier.VerifyTable(reinterpret_cast<const TileMap *>(union_obj));
    case AnyNode_Node: return verifier.VerifyTable(reinterpret_cast<const Node *>(union_obj));
    default: return false;
  }
}

inline const creator::buffers::SceneGraph *GetSceneGraph(const void *buf) {
  return flatbuffers::GetRoot<creator::buffers::SceneGraph>(buf);
}

inline const char *SceneGraphIdentifier() {
  return "CCRE";
}

inline bool SceneGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, SceneGraphIdentifier());
}

inline bool VerifySceneGraphBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<creator::buffers::SceneGraph>(SceneGraphIdentifier());
}

inline const char *SceneGraphExtension() { return "ccreator"; }

inline void FinishSceneGraphBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<creator::buffers::SceneGraph> root) {
  fbb.Finish(root, SceneGraphIdentifier());
}

}  // namespace buffers
}  // namespace creator

#endif  // FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
